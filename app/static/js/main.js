// FolderLens JavaScript\nclass FolderAnalyzer {\n    constructor() {\n        this.currentData = null;\n        this.initializeElements();\n        this.bindEvents();\n    }\n\n    initializeElements() {\n        // Input elements\n        this.folderInput = document.getElementById('folderInput');\n        this.folderPath = document.getElementById('folderPath');\n        this.browseBtn = document.getElementById('browseBtn');\n        this.analyzeBtn = document.getElementById('analyzeBtn');\n\n        // Section elements\n        this.loadingSection = document.getElementById('loadingSection');\n        this.resultsSection = document.getElementById('resultsSection');\n        this.errorSection = document.getElementById('errorSection');\n\n        // Results elements\n        this.totalFiles = document.getElementById('totalFiles');\n        this.totalSize = document.getElementById('totalSize');\n        this.largestFile = document.getElementById('largestFile');\n        this.largestFileSize = document.getElementById('largestFileSize');\n        this.mostCommonType = document.getElementById('mostCommonType');\n        this.mostCommonCount = document.getElementById('mostCommonCount');\n        this.fileTypesBody = document.getElementById('fileTypesBody');\n\n        // Export elements\n        this.exportCsvBtn = document.getElementById('exportCsvBtn');\n        this.exportPdfBtn = document.getElementById('exportPdfBtn');\n\n        // Error elements\n        this.errorText = document.getElementById('errorText');\n\n        // Modal elements\n        this.fileDetailsModal = document.getElementById('fileDetailsModal');\n        this.modalTitle = document.getElementById('modalTitle');\n        this.modalSummary = document.getElementById('modalSummary');\n        this.fileDetailsBody = document.getElementById('fileDetailsBody');\n        this.closeModal = document.getElementById('closeModal');\n        this.pageCountHeader = document.getElementById('pageCountHeader');\n    }\n\n    bindEvents() {\n        // Browse button click\n        this.browseBtn.addEventListener('click', () => {\n            this.folderInput.click();\n        });\n\n        // Folder selection change\n        this.folderInput.addEventListener('change', (e) => {\n            if (e.target.files.length > 0) {\n                const file = e.target.files[0];\n                // Extract the folder name from webkitRelativePath\n                const folderName = file.webkitRelativePath.split('/')[0];\n                \n                // Try to construct a reasonable path or prompt user for full path\n                // Since we can't get the full system path due to browser security,\n                // we'll show the folder name and let user modify if needed\n                this.folderPath.value = folderName;\n                this.folderPath.readOnly = false;\n                this.folderPath.placeholder = `Enter full path (e.g., /Users/username/Documents/${folderName})`;\n                this.analyzeBtn.disabled = false;\n                \n                // Show a helpful message\n                this.showPathHint(folderName);\n            }\n        });\n\n        // Allow manual path entry\n        this.folderPath.addEventListener('input', (e) => {\n            this.analyzeBtn.disabled = e.target.value.trim() === '';\n        });\n\n        // Analyze button click\n        this.analyzeBtn.addEventListener('click', () => {\n            const path = this.folderPath.value.trim();\n            if (path) {\n                this.analyzeFolder(path);\n            }\n        });\n\n        // Export buttons\n        this.exportCsvBtn.addEventListener('click', () => {\n            this.exportCSV();\n        });\n\n        this.exportPdfBtn.addEventListener('click', () => {\n            this.exportPDF();\n        });\n\n        // Allow Enter key to trigger analysis\n        this.folderPath.addEventListener('keypress', (e) => {\n            if (e.key === 'Enter' && !this.analyzeBtn.disabled) {\n                this.analyzeFolder(this.folderPath.value.trim());\n            }\n        });\n\n        // Modal events\n        this.closeModal.addEventListener('click', () => {\n            this.hideModal();\n        });\n\n        // Close modal when clicking outside\n        this.fileDetailsModal.addEventListener('click', (e) => {\n            if (e.target === this.fileDetailsModal) {\n                this.hideModal();\n            }\n        });\n\n        // Close modal with Escape key\n        document.addEventListener('keydown', (e) => {\n            if (e.key === 'Escape' && this.fileDetailsModal.style.display === 'block') {\n                this.hideModal();\n            }\n        });\n    }\n\n    showSection(sectionName) {\n        // Hide all sections\n        this.loadingSection.style.display = 'none';\n        this.resultsSection.style.display = 'none';\n        this.errorSection.style.display = 'none';\n\n        // Show requested section\n        switch (sectionName) {\n            case 'loading':\n                this.loadingSection.style.display = 'block';\n                break;\n            case 'results':\n                this.resultsSection.style.display = 'block';\n                break;\n            case 'error':\n                this.errorSection.style.display = 'block';\n                break;\n        }\n    }\n\n    async analyzeFolder(folderPath) {\n        try {\n            this.hidePathHint();\n            this.showSection('loading');\n            this.analyzeBtn.disabled = true;\n\n            const response = await fetch('/api/scan-folder', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                },\n                body: JSON.stringify({ folder_path: folderPath })\n            });\n\n            if (!response.ok) {\n                const errorData = await response.json();\n                throw new Error(errorData.error || 'Failed to analyze folder');\n            }\n\n            const data = await response.json();\n            this.currentData = data;\n            this.displayResults(data);\n            this.showSection('results');\n\n        } catch (error) {\n            console.error('Analysis error:', error);\n            this.showError(`${error.message}\\n\\nPlease ensure you've entered the complete, valid path to the folder.`);\n        } finally {\n            this.analyzeBtn.disabled = false;\n        }\n    }\n\n    displayResults(data) {\n        const { summary, file_types } = data;\n\n        // Update summary cards\n        this.totalFiles.textContent = summary.total_files.toLocaleString();\n        this.totalSize.textContent = summary.total_size_formatted;\n        this.largestFile.textContent = summary.largest_file.name || 'N/A';\n        this.largestFileSize.textContent = summary.largest_file.size_formatted || '';\n\n        // Most common type\n        if (summary.most_common_types && summary.most_common_types.length > 0) {\n            const mostCommon = summary.most_common_types[0];\n            this.mostCommonType.textContent = mostCommon.extension;\n            this.mostCommonCount.textContent = `${mostCommon.count} files`;\n        } else {\n            this.mostCommonType.textContent = 'N/A';\n            this.mostCommonCount.textContent = '';\n        }\n\n        // Update file types table\n        this.updateFileTypesTable(file_types, summary.total_size);\n    }\n\n    updateFileTypesTable(fileTypes, totalSize) {\n        this.fileTypesBody.innerHTML = '';\n\n        fileTypes.forEach(fileType => {\n            const row = document.createElement('tr');\n            const percentage = totalSize > 0 ? ((fileType.total_size / totalSize) * 100).toFixed(1) : '0.0';\n            \n            row.innerHTML = `\n                <td><span class=\"clickable-extension\" data-extension=\"${this.escapeHtml(fileType.extension)}\">${this.escapeHtml(fileType.extension)}</span></td>\n                <td>${fileType.count.toLocaleString()}</td>\n                <td>${fileType.total_size_formatted}</td>\n                <td>${fileType.avg_size_formatted}</td>\n                <td>${percentage}%</td>\n            `;\n            \n            // Add click event to extension\n            const extensionElement = row.querySelector('.clickable-extension');\n            extensionElement.addEventListener('click', () => {\n                this.showFilesByExtension(fileType.extension);\n            });\n            \n            this.fileTypesBody.appendChild(row);\n        });\n    }\n\n    async exportCSV() {\n        if (!this.currentData) {\n            alert('No data to export. Please analyze a folder first.');\n            return;\n        }\n\n        try {\n            const response = await fetch('/api/export-csv', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                },\n                body: JSON.stringify(this.currentData)\n            });\n\n            if (!response.ok) {\n                throw new Error('Failed to export CSV');\n            }\n\n            const blob = await response.blob();\n            this.downloadFile(blob, 'folder_analysis.csv', 'text/csv');\n\n        } catch (error) {\n            console.error('CSV export error:', error);\n            alert('Failed to export CSV. Please try again.');\n        }\n    }\n\n    exportPDF() {\n        if (!this.currentData) {\n            alert('No data to export. Please analyze a folder first.');\n            return;\n        }\n\n        // Use browser's print-to-PDF functionality\n        // Hide non-essential elements for printing\n        const elementsToHide = [\n            document.querySelector('.folder-selection'),\n            document.querySelector('.export-actions'),\n            document.querySelector('footer')\n        ];\n\n        // Hide elements\n        elementsToHide.forEach(el => {\n            if (el) el.style.display = 'none';\n        });\n\n        // Add print styles\n        const printStyle = document.createElement('style');\n        printStyle.textContent = `\n            @media print {\n                body { margin: 0; }\n                .container { max-width: none; margin: 0; padding: 20px; }\n                .summary-cards { page-break-inside: avoid; }\n                .table-container { page-break-inside: avoid; }\n                .results-table { font-size: 12px; }\n            }\n        `;\n        document.head.appendChild(printStyle);\n\n        // Trigger print dialog\n        window.print();\n\n        // Restore elements after print\n        setTimeout(() => {\n            elementsToHide.forEach(el => {\n                if (el) el.style.display = '';\n            });\n            document.head.removeChild(printStyle);\n        }, 100);\n    }\n\n    downloadFile(blob, filename, contentType) {\n        const url = window.URL.createObjectURL(new Blob([blob], { type: contentType }));\n        const link = document.createElement('a');\n        link.href = url;\n        link.download = filename;\n        document.body.appendChild(link);\n        link.click();\n        document.body.removeChild(link);\n        window.URL.revokeObjectURL(url);\n    }\n\n    showError(message) {\n        this.errorText.textContent = message;\n        this.showSection('error');\n    }\n\n    escapeHtml(text) {\n        const div = document.createElement('div');\n        div.textContent = text;\n        return div.innerHTML;\n    }\n\n    showPathHint(folderName) {\n        // Create or update a hint message\n        let hintElement = document.getElementById('pathHint');\n        if (!hintElement) {\n            hintElement = document.createElement('div');\n            hintElement.id = 'pathHint';\n            hintElement.className = 'path-hint';\n            this.folderPath.parentNode.appendChild(hintElement);\n        }\n        \n        hintElement.innerHTML = `\n            <p><strong>Folder detected:</strong> \"${folderName}\"</p>\n            <p>Please enter the complete path to this folder in the field above.</p>\n            <p><em>Example: /Users/yourusername/Documents/${folderName}</em></p>\n        `;\n        hintElement.style.display = 'block';\n    }\n\n    hidePathHint() {\n        const hintElement = document.getElementById('pathHint');\n        if (hintElement) {\n            hintElement.style.display = 'none';\n        }\n    }\n\n    async showFilesByExtension(extension) {\n        if (!this.folderPath.value.trim()) {\n            alert('No folder path available');\n            return;\n        }\n\n        try {\n            this.showModal();\n            this.modalTitle.textContent = `Files with extension: ${extension}`;\n            this.modalSummary.textContent = 'Loading files...';\n            this.fileDetailsBody.innerHTML = '<tr><td colspan=\"4\">Loading...</td></tr>';\n\n            const response = await fetch('/api/get-files-by-extension', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                },\n                body: JSON.stringify({\n                    folder_path: this.folderPath.value.trim(),\n                    extension: extension\n                })\n            });\n\n            if (!response.ok) {\n                const errorData = await response.json();\n                throw new Error(errorData.error || 'Failed to get files');\n            }\n\n            const data = await response.json();\n            this.displayFileDetails(data);\n\n        } catch (error) {\n            console.error('Error getting files:', error);\n            this.modalSummary.textContent = `Error: ${error.message}`;\n            this.fileDetailsBody.innerHTML = '<tr><td colspan=\"4\">Failed to load files</td></tr>';\n        }\n    }\n\n    displayFileDetails(data) {\n        const { extension, files, count } = data;\n        \n        this.modalSummary.textContent = `Found ${count} ${extension} files`;\n        this.fileDetailsBody.innerHTML = '';\n\n        // Show/hide page count column based on file type\n        const isPdf = extension.toLowerCase() === '.pdf';\n        this.pageCountHeader.style.display = isPdf ? 'table-cell' : 'none';\n\n        if (files.length === 0) {\n            const colspan = isPdf ? 5 : 4;\n            this.fileDetailsBody.innerHTML = `<tr><td colspan=\"${colspan}\">No files found</td></tr>`;\n            return;\n        }\n\n        files.forEach(file => {\n            const row = document.createElement('tr');\n            \n            let pageCountCell = '';\n            if (isPdf) {\n                const pageText = file.page_count !== null && file.page_count !== undefined\n                    ? `${file.page_count} pages`\n                    : 'Unknown';\n                pageCountCell = `<td>${pageText}</td>`;\n            }\n            \n            row.innerHTML = `\n                <td><strong>${this.escapeHtml(file.name)}</strong></td>\n                <td>${file.size_formatted}</td>\n                <td><em>${this.escapeHtml(file.parent_folder)}</em></td>\n                ${pageCountCell}\n                <td>\n                    <button class=\"action-btn copy-path\" onclick=\"navigator.clipboard.writeText('${this.escapeHtml(file.full_path)}')\">Copy Path</button>\n                    <button class=\"action-btn open-location\" onclick=\"alert('Path: ${this.escapeHtml(file.full_path)}')\">Show Path</button>\n                </td>\n            `;\n            this.fileDetailsBody.appendChild(row);\n        });\n    }\n\n    showModal() {\n        this.fileDetailsModal.style.display = 'block';\n        document.body.style.overflow = 'hidden'; // Prevent background scrolling\n    }\n\n    hideModal() {\n        this.fileDetailsModal.style.display = 'none';\n        document.body.style.overflow = 'auto'; // Restore scrolling\n    }\n}\n\n// Initialize the application when DOM is loaded\ndocument.addEventListener('DOMContentLoaded', () => {\n    new FolderAnalyzer();\n});\n\n// Add some helpful utility functions\nwindow.FolderLensUtils = {\n    formatSize: (bytes) => {\n        if (bytes === 0) return '0 B';\n        const k = 1024;\n        const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];\n        const i = Math.floor(Math.log(bytes) / Math.log(k));\n        return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];\n    },\n\n    formatNumber: (num) => {\n        return num.toLocaleString();\n    }\n};"